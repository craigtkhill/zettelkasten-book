<!DOCTYPE HTML>
<html lang="en" class="colibri sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Craig Hill</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "colibri";
            const default_dark_theme = "colibri";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('colibri')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Craig Hill</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/craigtkhill" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <pre><code class="language-toml">[author]
name = "Craig Hill"
role = "Machine Learning, AI Applications and Data Engineer"
current_focus = "How to make coding fun again in an AI world"

[blog]
topics = [
    "artificial intelligence",
    "zettelkasten",
]
frequency = "irregular random rolling releases"

[contact]
github = "github.com/craigtkhill"
linkedin = "linkedin.com/in/craigtkhill"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><p>I've been having a lot of thoughts about AI lately. These thoughts on how we are using AI revolve around a singular point. Sure, developers are losing their precision, creativity, autonomy, but most severely, coding is not fun.</p>
<p>There was a branching point at which using AI to help code stopped being fun. This was around the time that developers started trading Copilot's basic line completion for more cursor-style vibe coding IDEs.</p>
<p>I notice that as LLMs take bigger and bigger steps, the quality of their output declines. Sure, they might do fantastically on benchmarks, but their benchmarks do not match my real-world use case. I try to hold in my mind the AI does not stand for Artificial Intelligence but instead it stands for "Articulate Idiot". It does so much so well on the surface but when I dig a little deeper, and have done enough reading and learning to be opinionated about a topic, I find so much of what it outputs is wrong or substandard. And with longer and longer outputs to audit, this becomes frustrating. So I can't rely on their APIs for a stable workflow. I'm not saying we should stop using AI for development. But we should stop relying on it. I don't want AI tools that write all the code. I want tools to write the code the way I want to write it.</p>
<p><img src="ai//images/keep-agents-on-leash.png" alt="Karpathy&#39;s AI-assisted coding workflow" />
<em>From Andrej Karpathy's talk at Y Combinator, showing his (evolving) approach to AI-assisted development workflows. The software community is still figuring out how to properly integrate these AI tools and there's genuine uncertainty about best practices. Despite Karpathys reputation as a vibe coder, he and myself, believe that letting LLMs generate large chunks of code is problematic especially in projects where code quality and precision matter. We need to figure out how to use it in a controlled, step-by-step collaboration instead of letting it run wild. Source: Karpathy, A. (2025). <a href="https://www.youtube.com/watch?v=LCEmiRjPEtQ">Software Is Changing (Again)</a></em></p>
<h2 id="requirements"><a class="header" href="#requirements">REQUIREMENTS</a></h2>
<p>As a developer...</p>
<ul>
<li>I want a pair programmer who helps me improve my coding skills, so that I can learn better practices and techniques through our collaboration.</li>
<li>I want a pair programmer who reviews and validates my code without writing it for me, so that I can catch errors and improve code quality.</li>
<li>I want to work with immediate feedback, so that I can validate code quickly and avoid wasting time moving slowly in big, imprecise steps.</li>
<li>I want to achieve a flow state so that I can be maximally productive and engaged with my work.</li>
<li>I want to refine my code line-by-line in real time, so that I can catch issues immediately rather than dealing with large, error-prone walls of code.</li>
<li>I want to understand my codebase and how it functions, so that I can maintain full ownership and knowledge of my system.</li>
<li>I want to maintain full control over system architecture and design decisions, so that the overall structure reflects my vision and requirements.</li>
</ul>
<p>As far as I can tell in my research, no one else is implementing AI to meet these requirements. The direction we are collectively heading has become so painful that I find myself in desperate need to try something different.</p>
<p>The goal is to make programming fun again, and who knows, maybe it will give me an advantage in reducing the amount of slop I need to clean up. Maybe there is a reason everyone is going in the same direction. However, it's not working for me.</p>
<div style="break-before: page; page-break-before: always;"></div><p>Before we dive into trying to make AI work better, here are some of the things I think AI does quite well.</p>
<h2 id="socratic-method"><a class="header" href="#socratic-method">Socratic Method</a></h2>
<p>Use AI to ask you questions to get you thinking.
Use AI to ask you questions about what you are not thinking about.
AI is great for this to help you clarify your ideas.
The opportunity of using AI to make breakthroughs in many fields, including mathematics, will be simply helping you identify ideas you were unaware of and apply it to your problem.</p>
<h2 id="good-enough-search"><a class="header" href="#good-enough-search">Good Enough Search</a></h2>
<p>AI is useful when you have no clue how to do something and want to get to an answer quickly.
But it is useless for finding optimal answers.
If you are pressed for time and you don't care enough about an answer to invest more time into it, then AI is certainly better than traditional web search or following your gut.
If it is something more serious, then you will need to check your answers.</p>
<h2 id="simple-debugging"><a class="header" href="#simple-debugging">Simple Debugging</a></h2>
<p>If you have a bug in your code, you should always try to figure it out yourself. It's a muscle that you need to keep flexing. Oftentimes, the error is simple to catch, especially if you use tools with helpful error messages. However, if you find yourself staring at a problem to the point that your brain is skipping over gaps, trying to figure out what might be going on, it's helpful to throw it into AI to get a second opinion. Usually, it works pretty well. But always be wary of false positives and don't ask AI to seek bugs that might be there. Its response is usually too noisy and unless you know what you are doing and can separate the wheat from the chaff, it's often counterproductive to take its suggestions wholesale.</p>
<h2 id="rapid-prototyping"><a class="header" href="#rapid-prototyping">Rapid Prototyping</a></h2>
<p>When you know what you want, AI sucks. When you don't know what you want, AI is great.
AI can be useful for experimentation as long as the results don't need to be reliable.
And with the cost of writing crappy code being reduced, you can now perform more experiments faster.
In problems where there is less time involved, AI performs better (2-hour projects).
However, when given more time, humans perform better (both AI and humans get 32-hour time budgets)
Problems involving more code favor humans, while fewer favor AI.
Also, if you think this is a trend that's changing, and there is evidence of a so-called Moore's Law of AI that suggests AI can exponentially perform tasks that take longer and longer, then I have news for you. It's true, but it comes at the cost of precision. An AI can perform tasks that take longer and longer, but when you look a the steps it takes to get there, its assumptions are often wildly off, providing a rocky foundation on which to build from.</p>
<p><img src="ai//images/human-vs-ai.png" alt="RE-Bench performance vs time budget" />
<em>Performance comparison showing optimal time allocations vary by agent type, with AI agents making faster initial progress but humans improving more rapidly with additional time. Source: Wijk et al. (2025). RE-Bench: Evaluating frontier AI R&amp;D capabilities of language model agents against human experts. METR.</em></p>
<h2 id="self-made-tools-and-systems"><a class="header" href="#self-made-tools-and-systems">Self-Made Tools and Systems</a></h2>
<p>If you know how to use your tools, using AI often isn't that helpful. If you know how to write code and know what you want, then it is often faster to write the code yourself rather than repeatedly prompt AI until it gives you the code you are looking for. Sometimes you may have processes that you understand very well and are worthwhile automating. AI is great for these tasks. However, I suggest you create a system that uses AI to funnel data into it rather than using the AI (and I mean specifically the model) as the system itself. Not only is this more reliable, but it will also give you an advantage, so long as your system isn't easily sherlocked, you'll have access to something that makes you more productive than anyone else has.</p>
<h2 id="deeptech-breakthroughs"><a class="header" href="#deeptech-breakthroughs">Deeptech Breakthroughs</a></h2>
<p>AI is terrible, especially if you ask it about a domain you know nothing about. But if you know a domain very well and ask the right questions, it can reveal insights that can help you make breakthroughs. Granted, 90% of its suggestions will be pure hocum but if you know your stuff, AI can still be helpful, and you can identify a little golden nugget to explore. Always, check its sources. AI does make progress in deep technical challenges. Google DeepMind created AlphaEvolve, an AI system that found an algorithm to multiply 4x4 complex-valued matrices using 48 scalar multiplications, improving upon Strassen's 1969 algorithm. You should think about this sort of discovery exactly like evolution, the probablility of a new discovery or improvement is extremely small, so if you are prepared to burn down the rainforest and you know how to evaluate an answer is correct, you can make a breakthrough, hopefully that breakthrough is on how not to burn down the rainforest.</p>
<div style="break-before: page; page-break-before: always;"></div><p>The future of AI-assisted software engineering is not writing code; it's pair programming.
Pair programming with a colleague is where you take turns to be the driver and navigator.</p>
<ul>
<li><strong>Driver:</strong>
<ul>
<li>Controls the keyboard and mouse</li>
<li>Writes the actual code</li>
<li>Focuses on the immediate task of implementing the current line or function</li>
<li>Handles the tactical, detailed work of coding syntax and mechanics</li>
</ul>
</li>
<li><strong>Navigator:</strong>
<ul>
<li>Reviews the code as it's being written</li>
<li>Thinks about the bigger picture and overall direction</li>
<li>Spot potential issues, bugs, or improvements</li>
<li>Considers the broader architecture and design decisions</li>
<li>Asks questions and suggests alternatives</li>
</ul>
</li>
</ul>
<p>The reason to pair program is to get extra eyes on the code, spread understanding, reduce technical debt, and share learning.</p>
<p>Right now, the way we are using AI can be considered pair programming where the human is the navigator, prompting AI to drive the code generation.
But what if the software engineer is the driver and AI the navigator?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="limitations-are-good"><a class="header" href="#limitations-are-good">Limitations are good</a></h1>
<p>If you find yourself using AI to fix every problem, it can be difficult to wean yourself off. You need immense coding skills you set yourself apart from AI, and you won't learn those relying on AI.</p>
<p>At first, it can feel like you are moving at a glacial pace. Using AI gets you there quickly, but you need to slow down to really learn something. To let the thoughts marinate in your brain and take root, you need to go slow so that you can go fast later.</p>
<p>Start projects where there is no rush, no expectations, build those skills slowly, and limit your AI use.</p>
<p><em>Here are some ideas for limiting your AI use.</em></p>
<ol>
<li>Restrict yourself to basic plans.</li>
<li>Devote half your time to thinking without AI.</li>
<li>Ban yourself from copy/pasting code.</li>
<li>Read the documentation first to understand how a library works.</li>
<li>Use smaller locally hosted models</li>
<li>Develop your tools and use them.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><p>The number one slop stopper is to stop copy/pasting code.
When AI isn't changing large sections of your code, you are forced to read and understand what it is doing.
So keep the slop out of your IDE and find ways to make it harder for you to copy/paste code.
Use AI, let it show you how to do something, but never copy/paste large blocks of code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-you-should-work-on"><a class="header" href="#what-you-should-work-on">What you should work on</a></h1>
<ul>
<li>If AI can't figure something out in three prompts, then you know that's a good sign it's worth your while investigating with human intelligence.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advantage-in-an-ai-world"><a class="header" href="#advantage-in-an-ai-world">Advantage in an AI world</a></h1>
<p>If you just know how to use the models that everyone uses or the tools that everyone uses, then you will be a commodity.</p>
<p>AI cannot do the really interesting stuff, which is solving really hard problems that involve understanding whole systems, and AI cannot understand the larger context of lots of decisions.</p>
<p>However, AI can guide decisions in systems, and that makes them powerful.</p>
<p>AI makes predictions, and predictions are a key input into decisions. But we also need judgment and data. And as humans, we can bring that all together.</p>
<p>It will be our own individual human-driven systems, and I think systems that are opinionated, consistent, and deterministic, that will work better for true applications of AI. Systems enable defensibility and can scale. Systems are hard to copy because they are complex. And in an AI world, our superpower might be to build our systems that use AI to augment our decisions and allow us to do things that only we as individuals can do.</p>
<p>In other words, it's the applications built on top of AI that will be what separates the leaders from the pack.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>A <em>Zettelkasten</em> (German for "Note Box") is a garden for growing ideas you accumulate throughout your life. Over time it builds and becomes an architecture to structure your philosophy, help you to solve problems, and guide decisions.</p>
<p>Rather than scatter your digital knowledge throughout different projects, a Zettelkasten acts as your central knowledge management repository. It is the one place where everything you learn goes regardless of the project you are working on.</p>
<p>When you look online at other people's Zettelkasten systems, you'll notice each system is unique and personalized. And it should be. The workflow for your Zettelkasten should grow from your personal experience and needs as you use it. However, it can be daunting starting out, looking at how almost everyone makes their process super complicated. They take notes of everything they read. They spend hours writing their notes. And hours more fiddling with their processes. You don't need this. You need a system that's simple, portable, efficient, and practical. My process is much simpler. <em>Capture, Nurture, and Share</em>. Just read and listen and observe with a question in mind and write down what seems insightful and useful to you. Over time, you will develop an intuition to capture only that which resonates with you.</p>
<p>Think of consuming information as a panning for gold, the more you pan the more small amounts of gold build in the pan. You don't need to take notes on everything. Your system doesn't need to get bloated with information. You just need to pan for the few nuggets of gold that touch you every day in your digital garden's stream of thoughts to reap the benefits.</p>
<p>And this book will show you how to unlock the gold rush.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connecting-ideas"><a class="header" href="#connecting-ideas">Connecting Ideas</a></h1>
<p>The Unix philosophy suggests that programs should do one thing and do it well and your notes should do the same.</p>
<p>A rule of thumb is to keep notes short enough and to fit on a single screen without scrolling (and you should break this rule when needed).
When you are constrained, you are forced to think about the fundamentals of the idea you want to convey.
This is the key idea of atomic notes.</p>
<p>However, I go further, notes should not just be atomic, they should also be modular.
You should design your notes in such a way that you can easily move, link, and duplicate them in your knowledge system without any rewriting or refactoring.
This modularity allows you to easily connect and reconnect notes together.</p>
<p>Progress is rarely made by brute-force thinking.
Good ideas are rarely conjured from the ether.
Progress is more often made by making connections.</p>
<p>Writers make connections between ideas.
Engineers make connections between things.
Business leaders make connections between people.</p>
<p>By connecting notes we expand our learning and understanding.
By connecting ideas, we develop a framework to represent the data and facts of our respective areas of interest, enabling us to become experts in our field.
All that's left then is to elaborate on our network of connected ideas in a meaningful way.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capture-nurture-share"><a class="header" href="#capture-nurture-share">Capture Nurture Share</a></h1>
<p>The first elements of a Zettelkasten involve capturing, nurturing, and sharing.</p>
<h2 id="capture"><a class="header" href="#capture">Capture</a></h2>
<p>To capture I have a simple note app that takes in all my random thoughts.
I call this my "Mind Dump".</p>
<h2 id="nurture"><a class="header" href="#nurture">Nurture</a></h2>
<p>To nurture, each day I look at this random collection of notes, thematically organize them and paste the contents into a file that's related to the content.
Then I choose some areas I wish to clarify and organize these thoughts into coherent ideas.
Turning each thought into an individual note.</p>
<h2 id="share"><a class="header" href="#share">Share</a></h2>
<p>Finally, through this book, I express these thoughts.
The process of which refines my thinking and leads me further to nurture my ideas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-context-category-hierarchy"><a class="header" href="#time-context-category-hierarchy">Time-Context-Category-Hierarchy</a></h1>
<p><em>TCCH: A Latch Method alternative</em></p>
<p>To decide where to put our notes in relation to each other, it is helpful to use this process of organization.</p>
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<p>Time and attention are our most scarce resources. It is also the one most useful in making or notes discoverable when we need them most.
The first note should form the entry point to other notes that we can time-bound.
For example, I have a note that I check daily that reaches all other time-related notes.
This is useful for creating a routine of identifying and nurturing notes that are of most critical importance now.</p>
<h2 id="context"><a class="header" href="#context">Context</a></h2>
<p>These are notes that are grouped related to a specific problem or occasion you have encountered or may encounter.
They work a little bit like Time except there is no requirement schedule them in advance.
You just access the information as needed when you encounter the context, enabling you to can act on the fly to any situation.</p>
<h2 id="category"><a class="header" href="#category">Category</a></h2>
<p>These are the broad categories notes can belong to. You can think of them as genres for books or departments in a government.
They largely should not overlap with each other. Although there's no need to strictly enforce this.
It's just useful to know which category a thought belongs to or whether to create a new category.</p>
<h2 id="hierarchy"><a class="header" href="#hierarchy">Hierarchy</a></h2>
<p>This is where things get interesting.
In your categories you can break ideas into themes with as many layers of depth as you like.
I suggest you tackle this iteratively and over time. Ditto for the broad categories.
You want your broad categories to emerge as you merge and split ideas apart and group them into themes.
Keep going until your ideas can't be split apart and your broad themes are mutually exclusive.
This will leave you with a hierarchy of notes with different levels of detail going right down to the most fine-grained.
These are the atoms which you can now reassemble into an interesting chemistry of ideas.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zettelkasten-refactor-tool"><a class="header" href="#zettelkasten-refactor-tool">Zettelkasten Refactor Tool</a></h1>
<p>To help manage my Zettelkasten, I'm building <code>zrt</code> - the <em>Zettelkasten Refactor Tool</em>.
<code>zrt</code> has two primary goals.</p>
<ol>
<li>to be a command line tool to help nurture Zettelkasten notes and</li>
<li>to be an introductory project for me to learn the Rust programming language.</li>
</ol>
<p>My ordinary workflow involves using Obsidian. However, certain tasks require specific tools to help me with challenges I face.
Chief among them for me right now is the question of "What notes should I organize next?".</p>
<p>While I could create a plugin for Obsidian, I wanted something that doesn't rely on any particular interface
and that could be extended to work with any workflow, including Vim.</p>
<p>Hence, I started creating this cli tool in Rust. Welcome to the user guide and documentation for <code>zrt</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yaml-frontmatter"><a class="header" href="#yaml-frontmatter">YAML Frontmatter</a></h1>
<p>The first thing you need to know about <code>zrt</code> is that it uses yaml frontmatter to organize metadata about your notes.</p>
<p>Your YAML frontmatter should look like this and be placed at the very top of the file.</p>
<pre><code class="language-markdown">---
tags:
  - refactored
  - blogged
---
</code></pre>
<p><em>Note</em> The <code>refactored</code> tag lets me know that this note has already been processed and the <code>blogged</code> tag informs me that I have shared this note.</p>
<p>The tags you use are completely flexible. You can tag however you see fit.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ignoring-folders"><a class="header" href="#ignoring-folders">Ignoring Folders</a></h1>
<p>If there are files and folders you don't want to consider in your refactoring,
you can add a <code>.zrtignore</code> file to the root of your obsidian vault or knowledge management folder.</p>
<p>It works like a <code>.gitignore</code> file.</p>
<pre><code class="language-markdown"># /.zrtignore
ARCHIVE/
CALENDAR/
DRAWINGS/
IMAGES/
.git/
</code></pre>
<p>now the files in these folders will be ignored by the <code>zrt</code> tool.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="mode-rust.js"></script>
        <script src="editor.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
